// Generated by dts-bundle v0.7.3

declare module '@alalev/modular' {
   import { ProjectRoot } from "@alalev/modular/types/ProjectRoot";
   export * from "@alalev/modular/types";
   /**
     * Parse the file at the specified path synchronously. An error is thrown on failure.
     *
     * @export
     * @param {string} path The path to the XML file
     * @returns {ProjectRoot} The project root corresponding to the XML file
     */
   export function parseSync(path: string): ProjectRoot;
}

declare module '@alalev/modular/types/ProjectRoot' {
   import { Directory } from "@alalev/modular/types/Directory";
   import { XmlObjectBase } from "@alalev/modular/types/base/XmlObjectBase";
   /**
     * The project root. It contains all the default configurations for all modules as well
     * as the modules themselves. It should be the output of the Parser.
     *
     * @export
     * @class ProjectRoot
     * @extends {XmlObjectBase}
     */
   export class ProjectRoot extends XmlObjectBase {
      webpackFile: string;
      tsFolder: string;
      stylesFolder: string;
      rootDirectory: Directory;
      protected initialize(): void;
   }
}

declare module '@alalev/modular/types' {
   export { Dependency } from "@alalev/modular/types/Dependency";
   export { Directory } from "@alalev/modular/types/Directory";
   export { Module } from "@alalev/modular/types/Module";
   export { ProjectRoot } from "@alalev/modular/types/ProjectRoot";
}

declare module '@alalev/modular/types/Directory' {
   import { XmlObjectBase } from "@alalev/modular/types/base/XmlObjectBase";
   import { Module } from "@alalev/modular/types/Module";
   /**
     * Represents a real-life directory in the file system, which can contain subdirectories
     * and modules. It, of course, has a name as well.
     *
     * @export
     * @class Directory
     * @extends {XmlObjectBase}
     */
   export class Directory extends XmlObjectBase {
      directories: Directory[];
      allModules: Module[];
      protected initialize(): void;
      setParentDirectory(parentDirectory: string): void;
   }
}

declare module '@alalev/modular/types/base/XmlObjectBase' {
   import { AdaptedData } from "@alalev/modular/core/AdaptedData";
   import { XmlObject } from "@alalev/modular/XmlObject";
   import { XmlObjectClass } from "@alalev/modular/core/XmlObjectClass";
   /**
      * The base abstract class all concrete XML object classes should extend.
      *
      * @export
      * @abstract
      * @class XmlObjectBase
      * @implements {XmlObject}
      */
   export abstract class XmlObjectBase implements XmlObject {
         protected data: AdaptedData;
         /**
            * Creates an instance of this XML object type.
            *
            * Instantiating with null or undefined data causes the 'initialize' method to never
            * be called and turning this object into a shell, ready to be mocked in unit tests.
            *
            * Another way to make mocking possible is to extend every single concrete XML object
            * type, but that is a much bigger overhead than ensuring that the "truthiness" check
            * upon the 'data' parameter works.
            *
            * @param {AdaptedData} data
            * @memberof XmlObjectBase
            */
         constructor(data: AdaptedData);
         protected instantiateChild<T extends XmlObject>(clazz: XmlObjectClass<T>): T;
         protected instantiateChildren<T extends XmlObject>(clazz: XmlObjectClass<T>): T[];
         protected abstract initialize(): void;
   }
}

declare module '@alalev/modular/types/Dependency' {
   import { XmlObjectBase } from "@alalev/modular/types/base/XmlObjectBase";
   /**
     * An XML object describing a dependency to a module. It only contains data
     * about the module that is being depended on because it is assumed that the Dependency
     * instances are only inside the module that depends on the specified module.
     *
     * @export
     * @class Dependency
     * @extends {XmlObjectBase}
     */
   export class Dependency extends XmlObjectBase {
      id: string;
      protected initialize(): void;
      getId(): string;
   }
}

declare module '@alalev/modular/types/Module' {
   import { XmlObjectBase } from "@alalev/modular/types/base/XmlObjectBase";
   import { Dependency } from "@alalev/modular/types/Dependency";
   /**
     * A module.
     *
     * @export
     * @class Module
     * @extends {XmlObjectBase}
     */
   export class Module extends XmlObjectBase {
      id: string;
      dependencies: Dependency[];
      directory: string;
      protected initialize(): void;
      setParentDirectory(directory: string): void;
   }
}

declare module '@alalev/modular/core/AdaptedData' {
   import { Assertion } from "@alalev/modular/assertions/Assertion";
   /**
      * Represents an XML object. It has content, attributes and children along with methods
      * to access them.
      *
      * @export
      * @interface AdaptedData
      */
   export interface AdaptedData {
         /**
            * Gets exactly 1 child of type 'tagname'. If there are 0 or more than one child,
            * an ExpectedSingleChildError error is thrown.
            *
            * @param {string} tagname
            * @returns {AdaptedData[]} The child
            * @memberof AdaptedData
            */
         getSingleChild(tagname: string): AdaptedData;
         /**
            * Gets all children of type 'tagname'.
            *
            * @param {string} tagname
            * @returns {AdaptedData[]} The children
            * @memberof AdaptedData
            */
         getChildren(tagname: string): AdaptedData[];
         /**
            * Get the content of the XML object.
            *
            * @param {Assertion[]} [assertions=empty array] Assertions to apply to the content.
            *
            * @returns {string} The content
            * @memberof AdaptedData
            */
         getContent(assertions?: Assertion[]): string;
         /**
            * Get an attribute of the XML object. If the attribute does not exist, an
            * {@link AttributeNotFoundError} is thrown.
            *
            * @param {string} key The key of the attribute.
            * @param {Assertion][]} [assertions=empty array] Whether the attribute is mandatory.
            *    If set to <code>true</code> and there is no such attribute,
            *       an AttributeNotFoundError is thrown.
            *    If set to <code>false</code> and there is no such attribute,
            *       <code>null</code> is returned.
            * @returns {string} The attribute
            * @memberof AdaptedData
            */
         getAttribute(key: string, assertions?: Assertion[]): string;
   }
}

declare module '@alalev/modular/XmlObject' {
   /**
     * An XML element/object, possibly with its own content/children/attributes.
     *
     * @export
     * @interface XmlObject
     */
   export interface XmlObject {
   }
}

declare module '@alalev/modular/core/XmlObjectClass' {
   import { XmlObject } from "@alalev/modular/XmlObject";
   import { AdaptedData } from "@alalev/modular/core/AdaptedData";
   export type XmlObjectClass<T extends XmlObject> = {
      new (data: AdaptedData): T;
   };
}

declare module '@alalev/modular/assertions/Assertion' {
   /**
      * An assertion that is to be made upon a string.
      *
      * @export
      * @interface Assertion
      */
   export interface Assertion {
         /**
            * Render the assertion fatal, which makes it throw an error when being run.
            *
            * @returns {Assertion}
            * @memberof Assertion
            */
         fatal(): Assertion;
         /**
            * Render the assertion safe, which makes it NOT throw an error when being run.
            *
            * @returns {Assertion}
            * @memberof Assertion
            */
         safe(): Assertion;
         /**
            * Whether the data complies with the given assertion.
            *
            * @param {string} data
            * @returns {boolean}
            * @memberof Assertion
            */
         test(data: string): boolean;
         /**
            * Whether the assertion has been marked as safe. If it has not been marked as safe or
            * fatal, it is assumed to be fatal.
            *
            * @returns {boolean}
            * @memberof Assertion
            */
         isSafe(): boolean;
         /**
            * A brief message describing the assertion that can be used in error messages.
            *
            * @returns {string}
            * @memberof Assertion
            */
         message(): string;
   }
}

